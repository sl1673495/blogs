{"componentChunkName":"component---src-templates-blog-post-js","path":"/777786151/","result":{"data":{"site":{"siteMetadata":{"title":"ssh的博客","author":"ssh"}},"markdownRemark":{"id":"31a3106a-7d01-5ea3-aa08-6c29740522fb","html":"<blockquote>\n<p>原文地址：<a href=\"https://sebastienlorber.com/atomic-css-in-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sebastienlorber.com/atomic-css-in-js</a></p>\n<p>翻译 / 润色：ssh</p>\n</blockquote>\n<p>随着 Facebook 和 Twitter 最近的产品部署，我认为一个新的趋势正在缓慢增长:<strong>Atomic CSS-in-JS</strong>。</p>\n<p>在这篇文章中，我们将看到什么是Atomic CSS（原子 CSS），它如何与 Tailwind CSS 这种实用工具优先的样式库联系起来，目前很多大公司在 React 代码仓库中使用它们。</p>\n<p>由于我不是这方面的专家，所以我不会去深入探讨它的利弊。我只是希望能帮助你了解它的大致内容。</p>\n<p>先抛出一个令人开心的结论，新的 CSS 编写和构建方式让 Facebook 的主页<strong>减少了 80% 的 CSS 体积</strong>。</p>\n<h2 id=\"什么是原子-css？\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90-css%EF%BC%9F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是原子 CSS？</h2>\n<p>你可能听说过各种 CSS 方法，如 BEM, OOCSS…</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>button button--state-danger<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Danger button<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>现在，人们真的很喜欢 <a href=\"https://tailwindcss.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tailwind CSS</a> 和它的 <a href=\"https://tailwindcss.com/docs/utility-first\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">实用工具优先（utility-first）</a> 的概念。这与 Functional CSS 和 <a href=\"https://github.com/tachyons-css/tachyons\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tachyon</a> 这个库的理念非常接近。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span>\n  <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">></span></span>\n  Button\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>用海量的实用工具类（utility classes）组成的样式表，让我们可以在网页里大显身手。</p>\n<p>原子 CSS 就像是实用工具优先（utility-first）CSS 的一个极端版本: 所有 CSS 类都有一个唯一的 CSS 规则。原子 CSS 最初是由 Thierry Koblentz (Yahoo!)在 2013 年<a href=\"https://www.smashingmagazine.com/2013/10/challenging-css-best-practices-atomic-approach/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">挑战 CSS 最佳实践</a>时使用的。</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token comment\">/* 原子 CSS */</span>\n<span class=\"token selector\">.bw-2x</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">border-width</span><span class=\"token punctuation\">:</span> 2px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">.bss</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">border-style</span><span class=\"token punctuation\">:</span> solid<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">.sans</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">font-style</span><span class=\"token punctuation\">:</span> sans-serif<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">.p-1x</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> 10px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">/* 不是原子 CSS 因为这个类包含了两个规则 */</span>\n<span class=\"token selector\">.p-1x-sans</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> 10px<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">font-style</span><span class=\"token punctuation\">:</span> sans-serif<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>使用实用工具/原子 CSS，我们可以把结构层和表示层结合起来:当我们需要改变按钮颜色时，我们直接修改 HTML，而不是 CSS！</p>\n<p>这种<strong>紧密耦合</strong>在现代 CSS-in-JS 的 React 代码库中也得到了承认，但似乎 是 CSS 世界里最先对传统的<strong>关注点分离</strong>有一些异议。</p>\n<p>CSS 权重也不是什么问题，因为我们使用的是最简单的类选择器。</p>\n<p>我们现在通过 html 标签来添加样式，发现了一些有趣的事儿：</p>\n<ul>\n<li>我们增加新功能的时候，样式表的增长减缓了。</li>\n<li>我们可以到处移动 html 标签，并且能确保样式也同样生效。</li>\n<li>我们可以删除新特性，并且确保样式也同时被删掉了。</li>\n</ul>\n<p>可以肯定的缺点是，html 有点臃肿。对于服务器渲染的 web 应用程序来说可能是个缺点，但是类名中的高冗余使得 gzip 可以压缩得很好。同时它可以很好地处理之前重复的 css 规则。</p>\n<p>一旦你的实用工具/原子 CSS 准备好了，它将不会有太大的变化或增长。可以更有效地缓存它(你可以将它附加到 vendor.css 中，重新部署的时候它也不会失效)。它还具有相当好的可移植性，可以在任意其他应用程序中使用。</p>\n<h2 id=\"实用工具原子-css-的限制\"><a href=\"#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8E%9F%E5%AD%90-css-%E7%9A%84%E9%99%90%E5%88%B6\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实用工具/原子 CSS 的限制</h2>\n<p>实用工具/原子 CSS 看起来很有趣，但它们也带来了一些挑战。</p>\n<p>人们通常手工编写实用工具/原子 CSS，精心制定命名约定。但是很难保证这个约定易于使用、保持一致性，而且不会随着时间的推移而变得臃肿。</p>\n<p>这个 CSS 可以<strong>团队协作开发</strong>并保持<strong>一致性</strong>吗?它受<a href=\"https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A3%AB%E5%9B%A0%E5%AD%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>巴士因子</strong></a>的影响吗?</p>\n<blockquote>\n<p>巴士系数是软件开发中关于软件专案成员之间讯息与能力集中、未被共享的衡量指标，也有些人称作“货车因子”、“卡车因子”（lottery factor/truck factor）。一个专案或计划至少失去若干关键成员的参与（“被巴士撞了”，指代职业和生活方式变动、婚育、意外伤亡等任意导致缺席的缘由）即导致专案陷入混乱、瘫痪而无法存续时，这些成员的数量即为巴士系数。</p>\n</blockquote>\n<p>你还需要<strong>预先开发好</strong>一个不错的实用工具/原子样式表，然后才能开始开发新功能。</p>\n<p>如果实用工具/原子 CSS 是由别人制作的，你将不得不首先学习类命名约定(即使你知道 CSS 的一切)。这种约定是<strong>有主观性</strong>的，很可能你不喜欢它。</p>\n<p>有时，你需要一些<strong>额外的 CSS</strong>，而实用工具/原子 CSS 并不提供这些 CSS。没有约定好的方法来提供这些一次性样式。</p>\n<h2 id=\"tailwind-赶来支援\"><a href=\"#tailwind-%E8%B5%B6%E6%9D%A5%E6%94%AF%E6%8F%B4\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tailwind 赶来支援</h2>\n<p>Tailwind 使用的方法是非常便捷的，并且解决了上述一些问题。</p>\n<p>它通过 <strong>Utility-First</strong> 的理念来解决 CSS 的一些缺点，通过抽象出一组类名 -> 原子功能的集合，来避免你为每个 div 都写一个专有的 class，然后整个网站重复写很多重复的样式。</p>\n<p>传统卡片样式写法：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a75ec8a88d4586af9c59ce190a6293~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>Tailwind 卡片样式写法：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd33144e8d54c67b18ba15834e68ab1~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>它并不是真的为所有网站提供一些唯一的实用工具 CSS，取而代之的是，它提供了一些公用的命名约定。通过一个<a href=\"https://tailwindcss.com/docs/configuration\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">配置文件</a>，你可以为你的网站生成一套<strong>专属</strong>的实用工具 CSS。</p>\n<p>ssh 注：这里原作者没有深入介绍，为什么说是一套命名约定呢而不是生成一些定死的 CSS 呢？</p>\n<p>举几个例子让大家感受一些，Tailwind 提供了一套强大的构建系统，比如默认情况下它提供了一些响应式的断点值：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// tailwind.config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  theme<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    screens<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'sm'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'640px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// => @media (min-width: 640px) { ... }</span>\n\n      <span class=\"token string\">'md'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'768px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// => @media (min-width: 768px) { ... }</span>\n\n      <span class=\"token string\">'lg'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'1024px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// => @media (min-width: 1024px) { ... }</span>\n\n      <span class=\"token string\">'xl'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'1280px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">// => @media (min-width: 1280px) { ... }</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>你可以随时在配置文件中更改这些断点，比如你所需要的小屏幕 <code class=\"language-text\">sm</code> 可能指的是更小的 <code class=\"language-text\">320px</code>，那么你想要在小屏幕时候采用 flex 布局，还是照常写 <code class=\"language-text\">sm:flex</code>，遵循同样的约定，只是这个 <code class=\"language-text\">sm</code> 已经被你修改成适合于项目需求的值了。</p>\n<p>在比如说，Tailwind 里的 <code class=\"language-text\">spacing</code> 掌管了 margin、padding、width 等各个属性里的代表空间占用的值，默认是采用了 rem 单位，当你在配置里这样覆写后：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// tailwind.config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  theme<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    spacing<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'1'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'8px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'2'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'12px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'3'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'16px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'4'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'24px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'5'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'32px'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'6'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'48px'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>你再去写 <code class=\"language-text\">h-6</code>（height）, <code class=\"language-text\">m-2</code>（margin）, <code class=\"language-text\">mb-4</code>（margin-bottom），后面数字的意义就被你改变了。</p>\n<p>也许从桌面端换到移动端项目，这个 <code class=\"language-text\">6</code> 代表的含义变成了 <code class=\"language-text\">6rem</code>，但是这套约定却深深的印在你的脑海里，成为你知识的一部分了。</p>\n<p>Tailwind 的知识可以迁移到其他应用程序，即使它们使用的类名并不完全相同。这让我想起了 React 的「一次学习，到处编写」理念。</p>\n<p>我看到一些用户反馈说，Tailwind 提供的类名能覆盖他们 90% - 95% 的需求。这个覆盖面似乎已经足够广了，并不需要经常写一次性的 CSS 了。</p>\n<p>此时，你可能想知道<strong>为什么要使用原子 CSS 而不是 Tailwind CSS</strong>?强制执行原子 CSS 规则的<strong>一个规则，一个类名</strong>，有什么好处?你最终会得到更大的 html 标签和更烦人的命名约定吗?Tailwind 已经有了足够多的原子类了啊。</p>\n<p>那么，我们是否应该放弃原子 CSS 的想法，而仅仅使用 Tailwind CSS?</p>\n<p>Tailwind 是一个优秀的解决方案，但仍然有一些问题没有解决:</p>\n<ul>\n<li>需要学习一套主观的命名约定</li>\n<li>CSS 规则插入顺序仍然很重要</li>\n<li>未使用的规则可以轻松删除吗?</li>\n<li>我们如何处理剩下的一次性样式?</li>\n</ul>\n<p>与 Tailwind 相比，手写原子 CSS 可能<strong>不是最方便</strong>的。</p>\n<h2 id=\"和-css-in-js-比较\"><a href=\"#%E5%92%8C-css-in-js-%E6%AF%94%E8%BE%83\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>和 CSS-in-JS 比较</h2>\n<p>CSS-in-JS 和实用工具/原子 CSS 有密切关系。这两种方法都提倡使用<strong>标签</strong>进行样式化。以某种方式试图模仿<strong>内联样式</strong>，这让它们有了很多相似的特性(比如在移动某些功能的时候更有信心)。</p>\n<p><a href=\"https://twitter.com/vjeux\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Christopher Chedeau</a> 一直致力于推广 React 生态系统中 CSS-in-JS 理念。在很多次演讲中，他都解释了 CSS 的问题:</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d923a2dd76141a78242d0308e1d117a~tplv-k3u1fbpfcp-watermark.image\"></p>\n<ol>\n<li>全局命名空间</li>\n<li>依赖</li>\n<li>无用代码消除</li>\n<li>代码压缩</li>\n<li>共享常量</li>\n<li>非确定性（Non-Deterministic）解析</li>\n<li>隔离</li>\n</ol>\n<p>实用工具/原子 CSS 也解决了其中的一些问题，但也确实没法解决所有问题（特别是样式的<strong>非确定性解析</strong>)。</p>\n<p>如果它们有很多相似之处，那我们能否同时使用它们呢?</p>\n<h2 id=\"探索原子-css-in-js\"><a href=\"#%E6%8E%A2%E7%B4%A2%E5%8E%9F%E5%AD%90-css-in-js\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>探索原子 CSS-in-JS</h2>\n<p>原子 CSS-in-JS 可以被视为是“自动化的原子 CSS”：</p>\n<ul>\n<li>你不再需要创建一个 class 类名约定</li>\n<li>通用样式和一次性样式的处理方式是一样的</li>\n<li>能够提取页面所需要的的关键 CSS，并进行代码拆分</li>\n<li>有机会修复 JS 中 CSS 规则插入顺序的问题</li>\n</ul>\n<p>我想强调两个特定的解决方案，它们最近推动了两个大规模的原子 CSS-in-JS 的部署使用，来源于以下两个演讲。</p>\n<ul>\n<li>React-Native-Web at Twitter (更多细节在<a href=\"https://www.youtube.com/watch?v=tFFn39lLO-U\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Nicolas Gallagher 的演讲</a>)。</li>\n<li>Stylex at Facebook (更多细节在<a href=\"https://www.youtube.com/watch?v=9JZHodNR184\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Frank Yan 的演讲</a>)。</li>\n</ul>\n<p>也可以看看这些库：</p>\n<ul>\n<li>Styletron</li>\n<li>Fela</li>\n<li>Style-Sheet</li>\n<li>cxs</li>\n<li>otion</li>\n<li>css-zero</li>\n<li>ui-box</li>\n<li>style9</li>\n<li>stitches</li>\n<li>catom</li>\n</ul>\n<h3 id=\"react-native-web\"><a href=\"#react-native-web\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React-Native-Web</h3>\n<p>React-Native-Web 是一个非常有趣的库，让浏览器也可以渲染 React-Native 原语。不过我们这里并不讨论跨平台开发（演讲里有更多细节）。</p>\n<p>作为 web 开发人员，你只需要理解 React-Native-Web 是一个常规的 CSS-in-JS 库，它自带一些原始的 React 组件。所有你写 <code class=\"language-text\">View</code> 组件的地方，都可以用 div 替换。</p>\n<p>React-Native-Web 的作者是 Nicolas Gallagher，他致力于开发 Twitter 移动版。他们逐渐把它部署到移动设备上，不太确定具体时间，大概在 2017/2018 年左右。</p>\n<p>从那以后，很多公司都在用它(美国职业足球大联盟、Flipkart、Uber、纽约时报……)，但最重要的一次部署，则是由 Paul Armstrong 领导的团队在 2019 年推出的新的 Twitter 桌面应用。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f76238711cd46f7bbc27e27cb6e65b5~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h3 id=\"stylex\"><a href=\"#stylex\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stylex</h3>\n<p>Stylex 是一个新的 CSS-in-JS 库，Facebook 团队为了 2020 年的 Facebook 应用重构而开发它。未来可能会开源，有可能用另一个名字。</p>\n<p>值得一提的是，React-Native-Web 的作者 Nicolas Gallagher 被 Facebook 招安。所以里面出现一些熟悉的概念一点也不奇怪。</p>\n<p>我的所有信息都来自演讲 :)，还需要等待更多的细节。</p>\n<h2 id=\"可扩展性\"><a href=\"#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>可扩展性</h2>\n<p>不出所料，在 Atomic CSS 的加成下，Twitter 和 Facebook 的 CSS<strong>体积都大幅减少</strong>了，现在它的<strong>增长遵循的是对数曲线</strong>。不过，简单的应用则会多了一些 <strong>初始体积</strong>。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b528d6aa254a82a67b1ed7c57788ef~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6ef346634f44d218c6900f99353299d~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>Facebook 分享了具体数字:</p>\n<ul>\n<li>旧的网站<strong>仅仅首页</strong>就用了 <code class=\"language-text\">413Kb</code> 的 CSS</li>\n<li>新的网站<strong>整个站点</strong>只用了 <code class=\"language-text\">74Kb</code>，包括暗黑模式</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7681df905c74ce2a28f188f8ddb1c20~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h2 id=\"源码和输出\"><a href=\"#%E6%BA%90%E7%A0%81%E5%92%8C%E8%BE%93%E5%87%BA\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>源码和输出</h2>\n<p>这两个库的 API 看起来很相似，但也很难说，因为我们对 Stylex 了解不多。</p>\n<p>值得强调的是，React-Native-Web 会扩展 CSS 语法糖，比如 <code class=\"language-text\">margin: 0</code>，会被输出为 4 个方向的 margin 原子规则。</p>\n<p>以一个组件为例，来看看旧版传统 CSS 和新版原子 CSS 输出的区别。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Component1</span> <span class=\"token attr-name\">classNames</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>class1<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Component2</span> <span class=\"token attr-name\">classNames</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>class2<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.class1</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> mediumseagreen<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">cursor</span><span class=\"token punctuation\">:</span> default<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">margin-left</span><span class=\"token punctuation\">:</span> 0px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">.class2</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> thistle<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">cursor</span><span class=\"token punctuation\">:</span> default<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">jusify-content</span><span class=\"token punctuation\">:</span> flex-start<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">margin-left</span><span class=\"token punctuation\">:</span> 0px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看出这两个样式中 <code class=\"language-text\">cursor</code> 和 <code class=\"language-text\">margin-left</code> 是一模一样的，但它在输出中都会占体积。</p>\n<p>再来看看原子 CSS 的输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Component1</span> <span class=\"token attr-name\">classNames</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>classA classC classD<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Component2</span> <span class=\"token attr-name\">classNames</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>classA classB classD classE<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">class a</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">cursor</span><span class=\"token punctuation\">:</span> default<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">class b</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> mediumseagreen<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">class C</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> thistle<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">class D</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">margin-left</span><span class=\"token punctuation\">:</span> 0px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">class E</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">jusify-content</span><span class=\"token punctuation\">:</span> flex-start<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看出，虽然标签上的<strong>类名变多</strong>了，但是 CSS 的输出体积会<strong>随着功能的增多而减缓增长</strong>，因为出现过一次的 CSS Rule 就不会再重复出现了。</p>\n<h2 id=\"生产环境验证\"><a href=\"#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%AA%8C%E8%AF%81\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>生产环境验证</h2>\n<p>我们看看 Twitter 上的标签是什么样子的:</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ad731068ec64116b879df2fce8696f8~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>现在，让我们来看看新 Facebook:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ea33216ade1445ba7d075910333b4b0~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>很多人可能会被吓到，但是其实它很好用，而且保持了 <a href=\"https://github.com/necolas/react-native-web/blob/master/packages/docs/src/guides/accessibility.stories.mdx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">可访问性</a>。</p>\n<p>在 Chrome 里检查样式可能有点难，但 devtools 里就看得很清楚了:</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bfd4e96a8f546909d45b0322c690434~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h2 id=\"css-规则顺序\"><a href=\"#css-%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSS 规则顺序</h2>\n<p>与手写的工具/原子 CSS 不同，JS 库能让样式不依赖于 CSS 规则的插入顺序。</p>\n<p>在规则冲突的情况下，生效的不是标签上 class attribute 中的最后一个类，而是样式表中<strong>最后插入</strong>的规则。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05aadd15366a4658b166c8e5dca7f57a~tplv-k3u1fbpfcp-watermark.image\"></p>\n<p>以这张图为例，我们期望的是<strong>书写在后</strong>的 <code class=\"language-text\">blue</code> 类覆盖前面的类，但实际上 CSS 会以<strong>样式表中的顺序</strong>来决定优先级，最后我们看到的是红色的文字。</p>\n<p>在实际场景中，这些库避免在同一个元素上写入多个规则冲突的类。它们会确保标签上<strong>书写在最后</strong>的类名生效。其他的<strong>被覆盖</strong>的类名则被规律掉，甚至压根不会出现在 DOM 上。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> styles <span class=\"token operator\">=</span> pseudoLib<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  red<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>color<span class=\"token punctuation\">:</span> <span class=\"token string\">\"red\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  blue<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>color<span class=\"token punctuation\">:</span> <span class=\"token string\">\"blue\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 只会输出 blue 相关的 CSS</span>\n<span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">[</span>styles<span class=\"token punctuation\">.</span>red<span class=\"token punctuation\">,</span> styles<span class=\"token punctuation\">.</span>blue<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n  Always blue<span class=\"token operator\">!</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n\n<span class=\"token comment\">// 只会输出 red 相关的 CSS</span>\n<span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">[</span>styles<span class=\"token punctuation\">.</span>blue<span class=\"token punctuation\">,</span> styles<span class=\"token punctuation\">.</span>red<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n  Always red<span class=\"token operator\">!</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span></code></pre></div>\n<blockquote>\n<p>注意:只有使用最严格的原子 CSS 库才能实现这种可预测的行为。</p>\n</blockquote>\n<p>如果一个类里有多个 CSS 规则，并且只有其中的一个 CSS 规则被覆盖，那么 CSS-in-JS 库没办法进行相关的过滤，这也是原子 CSS 的优势之一。</p>\n<p>如果一个类只有一个简单的 CSS 规则，如 <code class=\"language-text\">margin: 0</code>，而覆盖的是 <code class=\"language-text\">marginTop: 10</code>。像 <code class=\"language-text\">margin: 0</code> 这样的简写语法被扩展为 4 个不同的原子类，这个库就能更加轻松的过滤掉不该出现在 DOM 上的类名。</p>\n<h2 id=\"仍然喜欢-tailwind？\"><a href=\"#%E4%BB%8D%E7%84%B6%E5%96%9C%E6%AC%A2-tailwind%EF%BC%9F\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>仍然喜欢 Tailwind？</h2>\n<p>只要你熟悉所有的 Tailwind 命名约定，你就可以很高效的完成 UI 编写。一旦你熟悉了这个设定，就很难回到手写每个 CSS 规则的时代了，就像你写 CSS-in-JS 那样。</p>\n<p>没什么能阻止你在原子 CSS-in-JS 的框架上建立你自己的抽象 CSS 规则，<a href=\"https://styled-system.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Styled-system</a> 就能在 CSS-in-JS 库里完成一些类似的事情。它基于一些约定创造出一些原子规则，在 <code class=\"language-text\">emotion</code> 中使用它试试：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> styled <span class=\"token keyword\">from</span> <span class=\"token string\">'@emotion/styled'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> typography<span class=\"token punctuation\">,</span> space<span class=\"token punctuation\">,</span> color <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'styled-system'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Box <span class=\"token operator\">=</span> <span class=\"token function\">styled</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>typography<span class=\"token punctuation\">,</span> space<span class=\"token punctuation\">,</span> color<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>等效于：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>Box\n  fontSize<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span>\n  fontWeight<span class=\"token operator\">=</span><span class=\"token string\">\"bold\"</span>\n  p<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span>\n  mb<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n  color<span class=\"token operator\">=</span><span class=\"token string\">\"white\"</span>\n  bg<span class=\"token operator\">=</span><span class=\"token string\">\"primary\"</span>\n<span class=\"token operator\">></span>\n  Hello\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Box<span class=\"token operator\">></span></code></pre></div>\n<p>甚至有可能在 JS 里复用一些 Tailwind 的命名约定，如果你喜欢的话。</p>\n<p>先看些 Tailwind 的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>absolute inset-0 p-4 bg-blue-500<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>我们在谷歌上随便找一个方案，比如我刚刚发现 <a href=\"https://www.npmjs.com/package/react-native-web-tailwindcss\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">react-native-web-tailwindcss</a>：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> t <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-native-tailwindcss'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">&lt;</span>View style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">.</span>absolute<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>inset0<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>p4<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>bgBlue500<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>就生产力的角度而言，并没有太大的不同。甚至可以用 TS 来避免错别字。</p>\n<h2 id=\"结论\"><a href=\"#%E7%BB%93%E8%AE%BA\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结论</h2>\n<p>这就是我要说的关于原子 CSS-in-JS 所有内容。</p>\n<p>我从来没有在任何大型生产部署中使用过原子 CSS、原子 CSS-in-JS 或 Tailwind。我可能在某些方面是错的，请随时纠正我。</p>\n<p>我觉得在 React 生态系统中，原子 CSS-in-JS 是一个非常值得关注的趋势，我希望你能从这篇文章中学到一些有用的东西。</p>\n<p>感谢阅读。</p>\n<hr>\n<blockquote>\n<p>“比较特殊的样式需求也不是什么问题，因为我们使用的是最简单的类选择器。” 这里翻译的不对，原文指的是 CSS Specificity。以及作为译文为什么没有贴原文链接？<a href=\"https://sebastienlorber.com/atomic-css-in-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sebastienlorber.com/atomic-css-in-js</a></p>\n</blockquote>\n<p>还未完成。。。 这里是草稿</p>\n<hr>\n<blockquote>\n<p>“比较特殊的样式需求也不是什么问题，因为我们使用的是最简单的类选择器。” 这里翻译的不对，原文指的是 CSS Specificity。以及作为译文为什么没有贴原文链接？<a href=\"https://sebastienlorber.com/atomic-css-in-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://sebastienlorber.com/atomic-css-in-js</a></p>\n</blockquote>\n<p>已经把完成度高一些的版本粘贴过来了，多谢大佬的指正~ 哈哈。</p>","timeToRead":14,"frontmatter":{"title":"Atomic CSS-in-JS","date":"January 04, 2021","spoiler":""},"fields":{"slug":"/777786151/","langKey":"en"}}},"pageContext":{"slug":"/777786151/","previous":{"fields":{"slug":"/769994836/","langKey":"en","directoryName":"769994836"},"frontmatter":{"title":"🔖TypeScript 备忘录：如何在 React 中完美运用？"}},"next":null,"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}